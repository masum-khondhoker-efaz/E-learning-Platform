generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id                String        @id @default(auto()) @map("_id") @db.ObjectId
  fullName          String
  email             String        @unique
  password          String?
  role              UserRoleEnum  @default(STUDENT)
  status            UserStatus    @default(PENDING)
  isVerified        Boolean       @default(false)
  isProfileComplete Boolean       @default(false)
  address           String?
  isLoggedIn        Boolean       @default(false)
  image             String?
  phoneNumber       String?
  dateOfBirth       String?
  gender            String?
  otp               Int?
  otpExpiry         DateTime?
  plateForm         PlatFormType?
  fcmToken          String?
  fcmTokenEx        String?
  stripeCustomerId  String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relationships
  roomsSent        Room[]             @relation("SenderRelation")
  roomsReceived    Room[]             @relation("ReceiverRelation")
  roomParticipants RoomUser[]
  chatsSent        Chat[]             @relation("SenderRelation")
  chatsReceived    Chat[]             @relation("ReceiverRelation")
  createdRooms     Room[]             @relation("CreatorRelation")
  Review           Review[]
  Faq              Faq[]
  TermAndCondition TermAndCondition[]
  PrivacyPolicy    PrivacyPolicy[]
  Admin            Admin[]
  Support          Support[]
  Reply            Reply[]
  Notification     Notification[]
  Payment          Payment[]
  Company          Company[]
  Category         Category[]
  Course           Course[]
  Test             Test[]
  TestAttempt      TestAttempt[]

  @@map("users")
}

model Admin {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  userId       String   @unique @db.ObjectId
  isSuperAdmin Boolean  @default(false)
  systemOwner  Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  @@map("admins")
}

model Company {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  userId         String   @db.ObjectId
  companyName    String
  companyAddress String
  vatId          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  @@map("companies")
}

model Category {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user   User     @relation(fields: [userId], references: [id])
  Course Course[]

  @@map("categories")
}

model Course {
  id                     String   @id @default(auto()) @map("_id") @db.ObjectId
  userId                 String   @db.ObjectId
  courseTitle            String
  courseShortDescription String
  courseDescription      String
  courseLevel            String
  categoryId             String   @db.ObjectId
  certificate            Boolean  @default(false)
  lifetimeAccess         Boolean  @default(false)
  price                  Float
  discountPrice          Float    @default(0)
  instructorName         String
  instructorImage        String
  instructorDesignation  String
  instructorDescription  String
  courseThumbnail        String
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  // Relationships
  user     User      @relation(fields: [userId], references: [id])
  category Category  @relation(fields: [categoryId], references: [id])
  Section  Section[]
  Test     Test[]

  @@map("courses")
}

model Section {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  courseId  String   @db.ObjectId
  title     String
  order     Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Lesson    Lesson[]

  // Relationships
  course Course @relation(fields: [courseId], references: [id])

  @@unique([courseId, order])
  @@map("sections")
}

model Lesson {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  sectionId String   @db.ObjectId
  title     String
  content   String
  order     Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  section Section @relation(fields: [sectionId], references: [id])

  @@unique([sectionId, order])
  @@map("lessons")
}

model Chat {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  senderId   String   @db.ObjectId
  receiverId String?  @db.ObjectId // Nullable for group chats
  roomId     String   @db.ObjectId
  message    String
  images     String[]
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relationships
  sender   User  @relation("SenderRelation", fields: [senderId], references: [id])
  receiver User? @relation("ReceiverRelation", fields: [receiverId], references: [id]) // Optional for group chats
  room     Room  @relation(fields: [roomId], references: [id])

  @@map("chats")
}

model Faq {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  question  String
  answer    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  @@map("faqs")
}

model Notification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  title     String
  body      String
  data      String?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  @@map("notifications")
}

model Payment {
  id                   String        @id @default(auto()) @map("_id") @db.ObjectId
  userId               String        @db.ObjectId
  stripeSubscriptionId String?
  paymentIntentId      String?
  paymentMethodId      String?
  paymentAmount        Float
  bookingId            String?       @db.ObjectId
  paymentDate          DateTime      @default(now())
  amountProvider       String
  amountReceiver       String?
  invoiceId            String?
  status               PaymentStatus @default(PENDING)
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@map("payments")
}

model PrivacyPolicy {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  heading   String?
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  @@map("privacy_policies")
}

model Reply {
  id        String      @id @default(auto()) @map("_id") @db.ObjectId
  userId    String      @db.ObjectId
  supportId String?     @db.ObjectId
  reportId  String?     @db.ObjectId
  message   String
  type      ReplyType   @default(SUPPORT)
  status    ReplyStatus @default(PENDING)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relationships
  support Support? @relation(fields: [supportId], references: [id])
  user    User     @relation(fields: [userId], references: [id])

  @@map("replies")
}

model Review {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  userId        String   @db.ObjectId
  barberId      String   @db.ObjectId
  saloonOwnerId String   @db.ObjectId
  bookingId     String   @db.ObjectId
  rating        Int
  comment       String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  @@map("reviews")
}

model Room {
  id               String   @id @default(auto()) @map("_id") @db.ObjectId
  type             RoomType @default(ONE_TO_ONE) // Type: One-to-one or Group chat
  groupName        String? // Name of the group (for group chats)
  groupDescription String? // Description of the group (for group chats)
  groupImage       String? // Image of the group (for group chats)
  senderId         String?  @db.ObjectId
  receiverId       String?  @db.ObjectId
  creatorId        String?  @db.ObjectId
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relationships
  sender   User? @relation("SenderRelation", fields: [senderId], references: [id])
  receiver User? @relation("ReceiverRelation", fields: [receiverId], references: [id])
  creator  User? @relation("CreatorRelation", fields: [creatorId], references: [id])

  participants RoomUser[] // Relationship to participants (RoomUser table)
  chat         Chat[]

  @@map("rooms")
}

model RoomUser {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  roomId String @db.ObjectId
  userId String @db.ObjectId

  // Relationships
  room Room @relation(fields: [roomId], references: [id])
  user User @relation(fields: [userId], references: [id])

  @@unique([userId, roomId])
  @@map("room_users")
}

model Support {
  id            String        @id @default(auto()) @map("_id") @db.ObjectId
  userId        String        @db.ObjectId
  userName      String
  subject       String?
  message       String
  status        SupportStatus @default(OPEN)
  type          SupportType
  saloonOwnerId String?       @db.ObjectId
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  Reply Reply[]

  @@map("supports")
}

model TermAndCondition {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  heading   String?
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id])

  @@map("terms_and_conditions")
}

model Test {
  id           String     @id @default(auto()) @map("_id") @db.ObjectId
  userId       String     @db.ObjectId
  courseId     String     @db.ObjectId
  title        String
  description  String?
  passingScore Int        @default(60) // Percentage or absolute score
  totalMarks   Int?       @default(100)
  timeLimit    Int? // Time limit in minutes
  isActive     Boolean    @default(true)
  isPublished  Boolean    @default(false)
  questions    Question[]
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  course      Course        @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  TestAttempt TestAttempt[]

  @@index([courseId])
  @@index([isActive])
  @@index([isPublished])
}

model Question {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  testId      String       @db.ObjectId
  title       String
  description String?
  type        QuestionType
  marks       Int          @default(1)
  explanation String? // Explanation for the answer
  order       Int? // Order within the test
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  test         Test           @relation(fields: [testId], references: [id], onDelete: Cascade)
  options      Option[] // For MCQ, True/False
  answers      Answer[] // For short answers
  UserResponse UserResponse[]

  @@index([testId])
  @@index([type])
  @@index([order])
}

model Option {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  questionId String   @db.ObjectId
  text       String
  isCorrect  Boolean  @default(false)
  order      Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId])
}

model Answer {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  questionId String   @db.ObjectId
  text       String // For short answers
  isCorrect  Boolean  @default(true) // For exact match checking
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId])
}

// Track test attempts and results
model TestAttempt {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  userId       String   @db.ObjectId
  testId       String   @db.ObjectId
  score        Int      // Auto-calculated score (MCQ + TrueFalse)
  totalMarks   Int      // Total marks of the test
  percentage   Float    // Auto-calculated percentage
  isPassed     Boolean  // Based on auto-graded questions only
  status       AttemptStatus @default(SUBMITTED) // New field
  timeSpent    Int      // Time spent in seconds
  completedAt  DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  test Test @relation(fields: [testId], references: [id], onDelete: Cascade)
  responses UserResponse[]

  @@index([userId])
  @@index([testId])
  @@index([status]) // New index
  @@index([isPassed])
  @@index([createdAt])
}

model UserResponse {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  attemptId       String   @db.ObjectId
  questionId      String   @db.ObjectId
  questionType    QuestionType
  selectedOptions String[] // For MCQ: array of option IDs
  shortAnswer     String?  // For short answers
  isCorrect       Boolean? // Null for short answers initially
  marksObtained   Int?     // Null for short answers initially
  status          ResponseStatus @default(SUBMITTED) // New field
  timeSpent       Int?     // Time spent on this question in seconds
  instructorNotes String?  // For manual grading notes

  attempt  TestAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([attemptId])
  @@index([questionId])
  @@index([status]) // New index
}

// New Enums
enum AttemptStatus {
  SUBMITTED     // Just submitted, auto-grading done
  UNDER_REVIEW  // Short answers need manual grading
  GRADED        // Fully graded (auto + manual)
  PUBLISHED     // Grades released to student
}

enum ResponseStatus {
  SUBMITTED    // Response submitted
  AUTO_GRADED  // MCQ/TrueFalse graded
  MANUAL_GRADED // Short answer graded by instructor
}

enum QuestionType {
  MCQ
  TRUE_FALSE
  SHORT_ANSWER
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CASH
  EXPIRED
  REFUNDED
  REQUIRES_CAPTURE
  CANCELLED
}

enum PlatFormType {
  GOOGLE
  FACEBOOK
  APPLE
}

enum ReplyStatus {
  PENDING
  IGNORED
  RESOLVED
  CLOSED
}

enum ReplyType {
  SUPPORT
  REPORT
}

enum RoomType {
  ONE_TO_ONE
  GROUP
}

enum SupportStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SupportType {
  CUSTOMER_QUESTION
  CUSTOMER_COMPLAINT
}

enum UserRoleEnum {
  STUDENT
  ADMIN
  SUPER_ADMIN
  INSTRUCTOR
}

enum UserStatus {
  ACTIVE
  PENDING
  BLOCKED
}
